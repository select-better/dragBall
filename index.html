<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        html,body{
            width: 100%;
            height: 100%
        }
        .ball{
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rebeccapurple;
            position: absolute;
            top: 100px;
            left: 100px;
            cursor: move;
        }
    </style>
</head>
<body>
    <div class="ball"></div>
    <script>
        class Drag{
            constructor(el){
                this.el = el;
                ['hozTimer', 'verticalTimer', 'curL','curT' ,'elL', 'elT', 'mouseL', 'mouseT', 'speedX', 'speedY'].forEach(item=>  this[item] = null );
                this.el.addEventListener('mousedown', this.onMouseDown.bind(this))
            }

            onMouseDown(ev){
                // 记录鼠标点下的初始位置
                const el = this.el
                this.elL = el.offsetLeft;
                this.elT = el.offsetTop;

                this.mouseL = ev.clientX;
                this.mouseT = ev.clientY;
                
                // 将事件绑定上
                this.mousemove = this.onMouseMove.bind(this)
                this.mouseUp = this.onMouseUp.bind(this)
                document.addEventListener('mousemove', this.mousemove)
                document.addEventListener('mouseup', this.mouseUp)
                // 将上一次的记录给去掉
                if(this.hozTimer){
                    clearInterval(this.hozTimer)
                }
                if(this.verticalTimer){
                    clearInterval(this.verticalTimer)
                }
                // 两次的数据
                this.speedX = undefined;
                this.speedY =undefined;
                this.isBegin = false
            }

            onMouseMove(ev){
                const el = this.el
                this.currentL = ev.clientX - this.mouseL + this.elL;
                this.currentT = ev.clientY - this.mouseT + this.elT;
                el.style.cssText = `left:${this.currentL}px; top:${this.currentT}px;`;
                
                if( !this.isBegin ){
                    this.lastL =  this.currentL;
                    this.lastT =  this.currentT;
                    this.speedX = 0;
                    this.speedY = 0;
                    this.isBegin = true
                    return;
                }

                this.speedX = this.currentL -  this.lastL;
                this.speedY = this.currentT -  this.lastT;
                this.lastL =  this.currentL;
                this.lastT =  this.currentT;
            }

            onMouseUp(ev){
                document.removeEventListener('mousemove', this.mousemove)
                document.removeEventListener('mouseup', this.mouseUp)
                this.isBegin = false
                // 触发计算时间
                this.onHoz.call(this)
                this.onVertical.call(this)
            }

            onHoz(){
                const el = this.el;
                if(this.hozTimer){
                    clearInterval(this.hozTimer)
                }
                const min = 0,maxL = document.documentElement.clientWidth - el.offsetWidth;
                let moveX = el.offsetLeft;
                let speedX = this.speedX;
                this.hozTimer = setInterval(()=>{
                    speedX *=0.98;
                    Math.abs(speedX)<=0.1?clearInterval(this.hozTimer):null;
                    moveX += speedX;
                    if(moveX<=0){
                        moveX = 0;
                        speedX *= -1;
                    }

                    if(moveX >= maxL){
                        moveX = maxL;
                        speedX *= -1;
                    }
                    el.style.left = `${moveX}px`
                }, 20)
                
            }

            onVertical(){
                const el = this.el;
                if(this.verticalTimer){
                    clearInterval(this.verticalTimer)
                }
                const min = 0,maxT = document.documentElement.clientHeight - el.offsetHeight;
                let moveT = el.offsetTop;
                let speedY = this.speedY;
                this.verticalTimer = setInterval(()=>{
                    speedY += 9.9;
                    speedY *=0.98;
                    Math.abs(speedY)<=0.1?clearInterval(this.verticalTimer):null;
                    moveT += speedY;
                    if(moveT<=0){
                        moveT = 0;
                        speedY *= -1;
                    }

                    if(moveT >= maxT){
                        moveT = maxT;
                        speedY *= -1;
                    }
                    console.log(speedY, moveT)
                    el.style.top = `${moveT}px`
                }, 20)
            }
        }
        const dom = document.querySelector('.ball')
        new Drag(dom)
    </script>
</body>
</html>